// -------------------------------------------------------------
//
// Module: cic1
// Generated by MATLAB(R) 23.2 and Filter Design HDL Coder 23.2.
// Generated on: 2024-05-02 15:25:22
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// FIRAdderStyle: tree
// OptimizeForHDL: on
// TargetDirectory: D:\fax\zavrsni\CIC1
// AddPipelineRegisters: on
// Name: cic1
// TargetLanguage: Verilog
// TestBenchName: cic1_tb
// TestBenchStimulus: step chirp 
// LoopUnrolling: on

// Filter Specifications:
//
// Sample Rate          : 705.6 kHz
// Response             : CIC Compensator
// Specification        : Fp,Fst,Ap,Ast
// Interpolation Factor : 2
// Multirate Type       : Interpolator
// Number of Sections   : 3
// Passband Edge        : 22.05 kHz
// Passband Ripple      : 0.001 dB
// Differential Delay   : 1
// Stopband Edge        : 330.8 kHz
// Stopband Atten.      : 60 dB
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// Folding Factor        : 1
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time FIR Multirate Filter (real)
// -----------------------------------------
// Filter Structure      : Direct-Form FIR Polyphase Interpolator
// Interpolation Factor  : 2
// Polyphase Length      : 3
// Filter Length         : 6
// Stable                : Yes
// Linear Phase          : Yes (Type 2)
//
// Arithmetic            : fixed
// Numerator             : s16,14 -> [-2 2)
// -------------------------------------------------------------




//`timescale 1 ns / 1 ns

module cic1
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out,
                ce_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   signed [17:0] filter_in; //sfix18_En15
  output  signed [18:0] filter_out; //sfix19_En15
  output  ce_out; 

////////////////////////////////////////////////////////////////
//Module Architecture: cic1
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter signed [15:0] coeffphase1_1 = 16'b1111011111001111; //sfix16_En14
  parameter signed [15:0] coeffphase1_2 = 16'b0100000000001000; //sfix16_En14
  parameter signed [15:0] coeffphase1_3 = 16'b0000100000101000; //sfix16_En14
  parameter signed [15:0] coeffphase2_1 = 16'b0000100000101000; //sfix16_En14
  parameter signed [15:0] coeffphase2_2 = 16'b0100000000001000; //sfix16_En14
  parameter signed [15:0] coeffphase2_3 = 16'b1111011111001111; //sfix16_En14

  // Signals
  reg  [1:0] cur_count; // ufix2
  wire phase_1; // boolean
  reg  signed [17:0] delay_pipeline [0:2] ; // sfix18_En15
  wire signed [33:0] product; // sfix34_En29
  wire signed [15:0] product_mux; // sfix16_En14
  wire signed [33:0] product_1; // sfix34_En29
  wire signed [15:0] product_mux_1; // sfix16_En14
  wire signed [33:0] product_2; // sfix34_En29
  wire signed [15:0] product_mux_2; // sfix16_En14
  wire signed [35:0] sumvector1 [0:1] ; // sfix36_En29
  wire signed [33:0] add_signext; // sfix34_En29
  wire signed [33:0] add_signext_1; // sfix34_En29
  wire signed [34:0] add_temp; // sfix35_En29
  reg  signed [35:0] sumdelay_pipeline1 [0:1] ; // sfix36_En29
  wire signed [35:0] sum2; // sfix36_En29
  wire signed [35:0] add_signext_2; // sfix36_En29
  wire signed [35:0] add_signext_3; // sfix36_En29
  wire signed [36:0] add_temp_1; // sfix37_En29
  wire signed [18:0] output_typeconvert; // sfix19_En15
  reg  signed [18:0] output_register; // sfix19_En15

  // Block Statements
  always @ (posedge clk or posedge reset)
    begin: ce_output
      if (reset == 1'b1) begin
        cur_count <= 2'b00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          if (cur_count >= 2'b01) begin
            cur_count <= 2'b00;
          end
          else begin
            cur_count <= cur_count + 2'b01;
          end
        end
      end
    end // ce_output

  assign  phase_1 = (cur_count == 2'b01 && clk_enable == 1'b1) ? 1'b1 : 1'b0;

  //   ---------------- Delay Registers ----------------

  always @( posedge clk or posedge reset)
    begin: Delay_Pipeline_process
      if (reset == 1'b1) begin
        delay_pipeline[0] <= 0;
        delay_pipeline[1] <= 0;
        delay_pipeline[2] <= 0;
      end
      else begin
        if (phase_1 == 1'b1) begin
          delay_pipeline[0] <= filter_in;
          delay_pipeline[1] <= delay_pipeline[0];
          delay_pipeline[2] <= delay_pipeline[1];
        end
      end
    end // Delay_Pipeline_process


  assign product_mux = (cur_count == 2'b00) ? coeffphase1_3 :
                      coeffphase2_3;
  assign product = delay_pipeline[2] * product_mux;

  assign product_mux_1 = (cur_count == 2'b00) ? coeffphase1_2 :
                        coeffphase2_2;
  assign product_1 = delay_pipeline[1] * product_mux_1;

  assign product_mux_2 = (cur_count == 2'b00) ? coeffphase1_1 :
                        coeffphase2_1;
  assign product_2 = delay_pipeline[0] * product_mux_2;

  assign add_signext = product;
  assign add_signext_1 = product_1;
  assign add_temp = add_signext + add_signext_1;
  assign sumvector1[0] = $signed({{1{add_temp[34]}}, add_temp});

  assign sumvector1[1] = $signed({{2{product_2[33]}}, product_2});

  always @ (posedge clk or posedge reset)
    begin: sumdelay_pipeline_process1
      if (reset == 1'b1) begin
        sumdelay_pipeline1[0] <= 0;
        sumdelay_pipeline1[1] <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          sumdelay_pipeline1[0] <= sumvector1[0];
          sumdelay_pipeline1[1] <= sumvector1[1];
        end
      end
    end // sumdelay_pipeline_process1

  assign add_signext_2 = sumdelay_pipeline1[0];
  assign add_signext_3 = sumdelay_pipeline1[1];
  assign add_temp_1 = add_signext_2 + add_signext_3;
  assign sum2 = ((add_temp_1[36] == 1'b0 & add_temp_1[35] != 1'b0) || (add_temp_1[36] == 1'b0 && add_temp_1[35:0] == 36'b011111111111111111111111111111111111) // special case0
) ? 36'b011111111111111111111111111111111111 : 
      (add_temp_1[36] == 1'b1 && add_temp_1[35] != 1'b1) ? 36'b100000000000000000000000000000000000 : add_temp_1[35:0];

  assign output_typeconvert = ((sum2[35] == 1'b0 & sum2[34:32] != 3'b000) || (sum2[35] == 1'b0 && sum2[32:14] == 19'b0111111111111111111) // special case0
) ? 19'b0111111111111111111 : 
      (sum2[35] == 1'b1 && sum2[34:32] != 3'b111) ? 19'b1000000000000000000 : (sum2[32:0] + {sum2[14], {13{~sum2[14]}}})>>>14;

  always @ (posedge clk or posedge reset)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign ce_out = phase_1;
  assign filter_out = output_register;
endmodule // cic1 
