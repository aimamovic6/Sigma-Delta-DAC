// -------------------------------------------------------------
//
// Module: cic4
// Generated by MATLAB(R) 23.2 and Filter Design HDL Coder 23.2.
// Generated on: 2024-05-02 15:54:45
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// FIRAdderStyle: tree
// OptimizeForHDL: on
// TargetDirectory: D:\fax\zavrsni\CIC4
// AddPipelineRegisters: on
// Name: cic4
// TargetLanguage: Verilog
// TestBenchName: cic4_tb
// TestBenchStimulus: step chirp 
// LoopUnrolling: on

// Filter Specifications:
//
// Sample Rate          : 5.644 MHz
// Response             : CIC Compensator
// Specification        : Fp,Fst,Ap,Ast
// Interpolation Factor : 2
// Multirate Type       : Interpolator
// Number of Sections   : 1
// Passband Edge        : 22.05 kHz
// Passband Ripple      : 0.001 dB
// Differential Delay   : 1
// Stopband Edge        : 2.8004 MHz
// Stopband Atten.      : 14 dB
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// Folding Factor        : 1
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time FIR Multirate Filter (real)
// -----------------------------------------
// Filter Structure      : Direct-Form FIR Polyphase Interpolator
// Interpolation Factor  : 2
// Polyphase Length      : 2
// Filter Length         : 4
// Stable                : Yes
// Linear Phase          : Yes (Type 2)
//
// Arithmetic            : fixed
// Numerator             : s17,15 -> [-2 2)
// -------------------------------------------------------------




//`timescale 1 ns / 1 ns

module cic4
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out,
                ce_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   signed [16:0] filter_in; //sfix17_En15
  output  signed [15:0] filter_out; //sfix16_En15
  output  ce_out; 

////////////////////////////////////////////////////////////////
//Module Architecture: cic4
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter signed [16:0] coeffphase1_1 = 17'b11110110100000011; //sfix17_En15
  parameter signed [16:0] coeffphase1_2 = 17'b01001001011111101; //sfix17_En15
  parameter signed [16:0] coeffphase2_1 = 17'b01001001011111101; //sfix17_En15
  parameter signed [16:0] coeffphase2_2 = 17'b11110110100000011; //sfix17_En15

  // Signals
  reg  [1:0] cur_count; // ufix2
  wire phase_1; // boolean
  reg  signed [16:0] delay_pipeline [0:1] ; // sfix17_En15
  wire signed [33:0] product; // sfix34_En30
  wire signed [16:0] product_mux; // sfix17_En15
  wire signed [33:0] product_1; // sfix34_En30
  wire signed [16:0] product_mux_1; // sfix17_En15
  wire signed [34:0] sum1; // sfix35_En30
  wire signed [33:0] add_signext; // sfix34_En30
  wire signed [33:0] add_signext_1; // sfix34_En30
  wire signed [15:0] output_typeconvert; // sfix16_En15
  reg  signed [15:0] output_register; // sfix16_En15

  // Block Statements
  always @ (posedge clk or posedge reset)
    begin: ce_output
      if (reset == 1'b1) begin
        cur_count <= 2'b00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          if (cur_count >= 2'b01) begin
            cur_count <= 2'b00;
          end
          else begin
            cur_count <= cur_count + 2'b01;
          end
        end
      end
    end // ce_output

  assign  phase_1 = (cur_count == 2'b01 && clk_enable == 1'b1) ? 1'b1 : 1'b0;

  //   ---------------- Delay Registers ----------------

  always @( posedge clk or posedge reset)
    begin: Delay_Pipeline_process
      if (reset == 1'b1) begin
        delay_pipeline[0] <= 0;
        delay_pipeline[1] <= 0;
      end
      else begin
        if (phase_1 == 1'b1) begin
          delay_pipeline[0] <= filter_in;
          delay_pipeline[1] <= delay_pipeline[0];
        end
      end
    end // Delay_Pipeline_process


  assign product_mux = (cur_count == 2'b00) ? coeffphase1_2 :
                      coeffphase2_2;
  assign product = delay_pipeline[1] * product_mux;

  assign product_mux_1 = (cur_count == 2'b00) ? coeffphase1_1 :
                        coeffphase2_1;
  assign product_1 = delay_pipeline[0] * product_mux_1;

  assign add_signext = product;
  assign add_signext_1 = product_1;
  assign sum1 = add_signext + add_signext_1;

  assign output_typeconvert = ((sum1[34] == 1'b0 & sum1[33:30] != 4'b0000) || (sum1[34] == 1'b0 && sum1[30:15] == 16'b0111111111111111) // special case0
) ? 16'b0111111111111111 : 
      (sum1[34] == 1'b1 && sum1[33:30] != 4'b1111) ? 16'b1000000000000000 : (sum1[30:0] + {sum1[15], {14{~sum1[15]}}})>>>15;

  always @ (posedge clk or posedge reset)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign ce_out = phase_1;
  assign filter_out = output_register;
endmodule  // cic4
